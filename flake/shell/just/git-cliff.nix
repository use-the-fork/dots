{
  perSystem = {pkgs, ...}: let
    git-cliff-config = pkgs.writeTextFile {
      name = "cliff.toml";
      text = ''
        # git-cliff ~ configuration file
        # https://git-cliff.org/docs/configuration

        [changelog]
        # template for the changelog footer
        header = """
        # Changelog\n
        All notable changes to this project will be documented in this file.\n
        """
        # template for the changelog body
        # https://keats.github.io/tera/docs/#introduction
        body = """
        ## [{{ now() | date(format="%Y-%m-%d") }}]
        {% for group, commits in commits | group_by(attribute="group") %}
            ### {{ group | upper_first }}
            {% for commit in commits
            | filter(attribute="scope")
            | sort(attribute="scope") %}
                - *({{commit.scope}})* {{ commit.message | upper_first }} - ([{{ commit.id | truncate(length=7, end="") }}](https://github.com/{{ remote.github.owner }}/{{ remote.github.repo }}/commit/{{ commit.id }})) - {{ commit.author.name }}
                {%- if commit.breaking %}
                {% raw %}  {% endraw %}- **BREAKING**: {{commit.breaking_description}}
                {%- endif -%}
            {%- endfor -%}
            {% raw %}\n{% endraw %}\
            {%- for commit in commits %}
                {%- if commit.scope -%}
                {% else -%}
                    - *(No Category)* {{ commit.message | upper_first }}
                    {% if commit.breaking -%}
                    {% raw %}  {% endraw %}- **BREAKING**: {{commit.breaking_description}}
                    {% endif -%}
                {% endif -%}
            {% endfor -%}
            {% raw %}\n{% endraw %}\
        {% endfor %}\n
        """
        # template for the changelog footer
        footer = """
        <!-- generated by git-cliff -->
        """
        # remove the leading and trailing whitespace from the templates
        trim = true

        [git]
        # parse the commits based on https://www.conventionalcommits.org
        conventional_commits = true
        # filter out the commits that are not conventional
        filter_unconventional = true
        # process each line of a commit as an individual commit
        split_commits = false
        # regex for parsing and grouping commits
        commit_parsers = [
          { message = "^feat", group = "<!-- 0 -->‚õ∞Ô∏è  Features" },
          { message = "^fix", group = "<!-- 1 -->üêõ Bug Fixes" },
          { message = "^docs", group = "<!-- 2 -->üìö Documentation" },
          { message = "^perf", group = "<!-- 3 -->‚ö° Performance" },
          { message = "^refactor", group = "<!-- 4 -->üöú Refactor" },
          { message = "^style", group = "<!-- 5 -->üé® Styling" },
          { message = "^test", group = "<!-- 6 -->üß™ Testing" },
          { message = "^chore", group = "<!-- 7 -->üîß Chores" },
          { message = "^ci", group = "<!-- 8 -->üõ†Ô∏è Continuous Integration" },
          { message = "^build", group = "<!-- 9 -->üèóÔ∏è Build System" },
          { message = "^revert", group = "<!-- 10 -->‚óÄÔ∏è Revert" }
        ]
        # protect breaking changes from being skipped due to matching a skipping commit_parser
        protect_breaking_commits = false
        # filter out the commits that are not matched by commit parsers
        filter_commits = false
        # regex for matching git tags
        tag_pattern = "v[0-9].*"
        # regex for skipping tags
        skip_tags = "v0.1.0-beta.1"
        # regex for ignoring tags
        ignore_tags = ""
        # sort the tags topologically
        topo_order = false
        # sort the commits inside sections by oldest/newest order
        sort_commits = "oldest"
      '';
    };

    git-cliff-entry = pkgs.writeShellScriptBin "git-cliff" ''
      # Get the remote URL
      REMOTE_URL=$(git config --get remote.origin.url)

      # Extract the owner and repo name from the URL
      if [[ $REMOTE_URL =~ ^https://github.com/(.*)/(.*)\.git$ ]]; then
          OWNER=''${BASH_REMATCH[1]}
          REPO=''${BASH_REMATCH[2]}
      elif [[ $REMOTE_URL =~ ^git@github.com:(.*)/(.*)\.git$ ]]; then
          OWNER=''${BASH_REMATCH[1]}
          REPO=''${BASH_REMATCH[2]}
      else
          echo "Unsupported remote URL format: $REMOTE_URL"
          exit 1
      fi

      # Combine owner and repo name
      GITHUB_REPO="$OWNER/$REPO"

      # Execute git-cliff with the extracted repo information
      ${pkgs.git-cliff}/bin/git-cliff \
      --bump \
      --output CHANGELOG.md \
      --config ${git-cliff-config.outPath} \
      --github-repo $GITHUB_REPO
    '';
  in {
    just-flake.features.cliff = {
      enable = true;
      justfile = ''
        # creates and updates the CHANGELOG.md using git-cliff.
        cliff:
          ${git-cliff-entry}/bin/git-cliff
      '';
    };
  };
}
